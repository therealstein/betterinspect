// cURL Builder - Generates cURL commands from network request data

class CurlBuilder {
  constructor() {
    this.maxLineLength = 80;
  }

  // Build cURL command from request object
  buildCurlCommand(request, options = {}) {
    const {
      includeHeaders = true,
      includeBody = true,
      multiline = true,
      escapeQuotes = true
    } = options;

    let curl = `curl -X ${request.method}`;

    if (multiline) {
      curl += ' \\';
    }

    // Add URL
    if (multiline) {
      curl += `\n  '${request.url}'`;
    } else {
      curl += ` '${request.url}'`;
    }

    // Add headers
    if (includeHeaders && Object.keys(request.requestHeaders).length > 0) {
      Object.entries(request.requestHeaders).forEach(([name, value]) => {
        const header = escapeQuotes 
          ? value.replace(/'/g, "'\\''")
          : value;
        
        if (multiline) {
          curl += ` \\\n  -H '${name}: ${header}'`;
        } else {
          curl += ` -H '${name}: ${header}'`;
        }
      });
    }

    // Add body if present
    if (includeBody && request.requestBody) {
      let body = request.requestBody;
      
      // Escape single quotes in body
      if (escapeQuotes) {
        body = body.replace(/'/g, "'\\''");
      }
      
      if (multiline) {
        curl += ` \\\n  -d '${body}'`;
      } else {
        curl += ` -d '${body}'`;
      }
    }

    // Add common flags
    if (request.method === 'POST' || request.method === 'PUT' || request.method === 'PATCH') {
      curl = this.addCompressedFlag(curl, multiline);
    }

    return curl;
  }

  // Build multiple cURL commands
  buildMultipleCurlCommands(requests, options = {}) {
    if (!requests || requests.length === 0) {
      return '# No requests to convert';
    }

    const preserveOrder = options.preserveOrder !== false;
    
    let sortedRequests = preserveOrder 
      ? requests.sort((a, b) => new Date(a.startedDateTime) - new Date(b.startedDateTime))
      : requests;

    let output = `# ${sortedRequests.length} cURL command${sortedRequests.length > 1 ? 's' : ''}\n`;
    output += `# Generated by betterinspect\n\n`;

    sortedRequests.forEach((request, index) => {
      output += `# Request #${index + 1}: ${request.method} ${this.extractPath(request.url)}\n`;
      output += this.buildCurlCommand(request, options);
      output += '\n\n';
    });

    return output;
  }

  // Add --compressed flag for better compatibility
  addCompressedFlag(curl, multiline) {
    if (multiline) {
      return curl + ' \\\n  --compressed';
    }
    return curl + ' --compressed';
  }

  // Extract path from URL for display
  extractPath(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.pathname + urlObj.search;
    } catch {
      return url;
    }
  }

  // Build a simplified version for display
  buildSimpleCurl(request) {
    let curl = `curl -X ${request.method} '${request.url}'`;
    
    if (request.requestBody) {
      const body = request.requestBody.replace(/'/g, "'\\''");
      curl += ` -d '${body}'`;
    }
    
    return curl;
  }

  // Generate cURL command with inline comments
  buildAnnotatedCurl(request) {
    let output = `# ${request.method} ${this.extractPath(request.url)}\n`;
    output += `# Status: ${request.responseStatus} ${request.responseStatusText}\n`;
    output += `# Time: ${request.time}ms\n\n`;
    output += this.buildCurlCommand(request);
    return output;
  }

  // Build cURL for specific use cases
  buildCurlForTesting(request) {
    // Optimized for testing/API debugging
    const options = {
      includeHeaders: true,
      includeBody: true,
      multiline: true,
      escapeQuotes: true
    };
    
    let curl = this.buildCurlCommand(request, options);
    
    // Add verbose flag for testing
    curl = curl.replace('curl', 'curl -v');
    
    return curl;
  }

  buildCurlForDocumentation(request) {
    // Clean version for documentation
    const options = {
      includeHeaders: true,
      includeBody: true,
      multiline: false,
      escapeQuotes: true
    };
    
    return this.buildCurlCommand(request, options);
  }

  // Convert request body to appropriate format
  formatRequestBody(request) {
    if (!request.requestBody) return '';
    
    try {
      // Try to parse as JSON
      const parsed = JSON.parse(request.requestBody);
      return JSON.stringify(parsed, null, 2);
    } catch {
      // Return as-is if not JSON
      return request.requestBody;
    }
  }

  // Validate cURL command
  validateCurlCommand(curlCommand) {
    // Basic validation
    const errors = [];
    
    if (!curlCommand.startsWith('curl')) {
      errors.push('Command must start with curl');
    }
    
    const urlMatch = curlCommand.match(/'([^']+)'/);
    if (!urlMatch) {
      errors.push('No URL found in command');
    } else {
      try {
        new URL(urlMatch[1]);
      } catch {
        errors.push('Invalid URL format');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    };
  }

  // Extract curl options
  parseCurlOptions(curlCommand) {
    const options = {
      method: 'GET',
      url: '',
      headers: {},
      body: ''
    };
    
    // Extract method
    const methodMatch = curlCommand.match(/-X\s+(\w+)/);
    if (methodMatch) {
      options.method = methodMatch[1];
    }
    
    // Extract URL
    const urlMatch = curlCommand.match(/'([^']+)'/);
    if (urlMatch) {
      options.url = urlMatch[1];
    }
    
    // Extract headers
    const headerMatches = curlCommand.matchAll(/-H\s+'([^:]+):\s*([^']+)'/g);
    for (const match of headerMatches) {
      options.headers[match[1]] = match[2];
    }
    
    // Extract body
    const bodyMatch = curlCommand.match(/-d\s+'([^']+)'/);
    if (bodyMatch) {
      options.body = bodyMatch[1];
    }
    
    return options;
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CurlBuilder;
}